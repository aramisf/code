<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<link rel="shortcut icon" href="http://qntm.org/page/favicon.ico">
		<title>Perl</title>

		<style type="text/css">
			@font-face {
				font-family: 'Ubuntu Mono';
				font-style: normal;
				font-weight: 700;
				src: local('Ubuntu Mono Bold'), local('UbuntuMono-Bold'), url('http://themes.googleusercontent.com/static/fonts/ubuntumono/v3/ceqTZGKHipo8pJj4molytjqR_3kx9_hJXbbyU8S6IN0.woff') format('woff');
			}
			body {
				padding: 2em;
				font-family: Tahoma;
			}
			pre {
				margin-left: 2em;
			}
			pre, code {
				color: #348275;
				font-family: "Ubuntu Mono", monospace;
			}
		</style>
	</head>

	<!-- http://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700|Roboto+Slab:400,700 -->
	<body>
<h1>Aprenda Perl em mais ou menos 2 horas 30 minutos</h1>
<h2>Escrito por <a href="http://qntm.org/perl">Sam Hughes</a>, traduzido por
  <a href="https://plus.google.com/111823334458712205300">Aramis
Fernandes</a></h2>

<p>Perl é uma linguagem dinâmica, tipada dinamicamente, de alto-nível, e
interpretada, bastante comparável com PHP e Python. Sua sintaxe deve muito à
antigas ferramentas de script do shell, e é famosa pelo uso exacerbado de
símbolos confusos, cuja maioria não pode ser buscada no Google. Esta herança
do shell faz do Perl uma linguagem muito boa para escrever códigos de
interface: scripts que unem outros scripts e programas. Perl é idealmente
projetado para processamento de dados de texto, produzindo mais dados de
texto. Perl é bem distribuído, popular, altamente portável e bem suportado.  O
Perl foi projetado com a filosofia "Há mais de uma forma de fazer isso" (do
inglês, TIMTOWTDI - "There is more than one way to do it.") (em contraste com
o Python, onde "deve haver uma - e preferencialmente uma - forma óbvia de
fazer isso").</p>

<p>Perl tem seus horrores, mas também possui grandes características
redentoras. Com respeito a isso é como qualquer outra linguagem de programação
já criada.</p>

<p>Este documento tem a intenção de ser informativo, e não evangelizador. É
dirigido a pessoas que, como eu:</p>
<ul>
  <li>não curte a documentação oficial do Perl em <a
    href="http://perl.org/">http://perl.org/</a> por ser intensivamente
  técnica e dar demasiado espaço para casos de uso bastante incomuns</li>
  <li>aprendem novas linguagens de programação mais rápido através do modelo
  "axioma e exemplo"</li>
  <li>gostariam que o Larry fosse mais direto ao ponto</li>
  <li>já sabem programar em termos gerais</li>
  <li>não se importam com o Perl além do necessário para ter o trabalho
  feito.</li>
</ul>
<p>Este documento é feito para ser tão curto quanto possível, mas não mais
curto que isso.</p>

<h2>Notas Preliminares</h2>
<ul>
  <li><p>Pode-se afirmar o seguinte para quase todo comando declarativa neste
  documento: "Isto não é, estritamente, verdade; a situação é na realidade bem
  mais complicada". Se você ver uma mentira grave, aponte, mas me reservo o
  direito de preservar certas mentiras 'perigosas para as crianças'</p></li>

  <li><p>Ao longo deste documento, estou usando exemplos com
  <code>print</code> para produzir dados mas não estou explicitamente usando
  quebras de linha. Isso é feito para evitar que eu enlouqueça e para dar
  maior atenção à string sendo impressa em cada caso, o que é invariavelmente
  mais importante. Em muitos exemplos isso resulta em
  muitaspalavrasexpremidasparaficartudoemumalinha se o código for executado de
  verdade.  Tente ignorar isso.</p></li>
</ul>

<h2>Hello world</h2>
<p>Um <i>script</i> Perl é um arquivo text com a extensão <code>.pl</code>.</p>
<p>Aqui está o texto completo de <code>helloworld.pl</code>:</p>
<pre class="perl">use strict;
use warnings;

<a href="http://perldoc.perl.org/functions/print.html">print</a> "Hello world";
</pre>
<p>Scripts Perl são interpretados pelo interpretador Perl, <code>perl</code>
ou <code>perl.exe</code>:</p>
<pre class="bash">perl helloworld.pl [arg0 [arg1 [arg2 ...]]]
</pre>

<p>Algumas notas rápidas. A sintaxe do Perl é altamente permissiva e vai
deixar que você faça coisas que resultam em afirmações aparentemente ambíguas
com comportamento imprevisível. Não há razão para eu explicar o que são tais
comportamentos, porque você quer evita-los. A maneira de evita-los é colocar
um <code>use strict; use warnings;</code> nas primeiras linhas de todo script
Perl ou módulo que você crie. Afirmações da forma <code>use foo;</code> são
<i>pragmas</i>. Uma pragma é um sinal para <code>perl.exe</code>, que tem
efeito quando a validação sintática inicial é feita, antes do program iniciar
sua execução. Essas linhas não possuem efeito algum quando o interpretador as
encontra em tempo de execução.</p>
<p>O ponto-e-vírgula, <code>;</code>, indica o final de uma linha. O símbolo
<code>#</code> inicia um comentário. Um comentário vai até o final da linha.
Não há sintaxe para blocos de comentário em Perl.

<h2>Variáveis</h2>
<p>As variáveis do Perl vem em 3 tipos: <i>escalares</i>, <i>arrays</i> e
<i>hashes</i>. Cada tipo tem seu próprio <i>símbolo</i>: <code>$</code>,
<code>@</code> e <code>%</code> respectivamente. Variáveis são declaradas
usando <code>my</code>, e permanecem no escopo até o final do bloco ou do
arquivo.</p>
<h3>Variáveis escalares</h3>
<p>Uma variável escalar pode conter:</p>
<ul>
  <li><code>undef</code> (corresponde ao <code>None</code> do Python,
  <code>null</code> do PHP)</li>
	<li>um número (Perl não distingue entre inteiro e float)</li>
	<li>uma string</li>
	<li>uma referência para qualquer outra variável.</li>
</ul>

<pre class="perl">my $undef = undef;
print $undef; # imprime a string vazia "" e produz um alerta

# undef implicito:
my $undef2;
print $undef2; # imprime "" e produz exatamente o mesmo alerta
</pre>

<pre class="perl">my $num = 4040.5;
print $num; # "4040.5"
</pre>

<pre class="perl">my $string = "world";
print $string; # "world"
</pre>

<p>(Referências virão em breve.)</p>
<p>Concatenação de strings usando o operador <code>.</code> (o mesmo do PHP):</p>
<pre class="perl">print "Hello ".$string; # "Hello world"
</pre>

<h3>"Booleanos"</h3>
<p><strong>Perl não possui o tipo booleano.</strong> Um escalar dentro de uma
condicional <code>if</code> é avaliado como o booleano "falso" se e somente se
é um dentre:</p>
<ul>
	<li><code>undef</code></li>
	<li>número <code>0</code></li>
	<li>string <code>""</code></li>
	<li>string <code>"0"</code>.</li>
</ul>

<p>A documentação do Perl <em>repetidamente</em> reforça que funções retornam
retornam valores "verdadeiro" ou "falso" em certas situações. Na prática
quando uma função é chamada para retornar "verdadeiro" ou "falso" ela
geralmente retorna <code>1</code>, e quando é chamada para retornar "falso"
ela geralmente retorna a string vazia, <code>""</code>.</p>

<h3>Tipagem fraca</h3>
<p><strong>É impossível determinar quando um escalar contém um "número" ou uma
  "string".</strong>
Mais precisamente, não deveria ser necessário fazer isso. Onde um escalar se
comporta como um número ou uma string depende do operador sendo usado. Quando
usado como uma string, um escalar se comportará como uma string. Quando usado
como um número, um escalar se comportará como um número (alertando quando isso
não for possível):</p>

<pre class="perl">my $str1 = "4G";
my $str2 = "4H";

print $str1 .  $str2; # "4G4H"
print $str1 +  $str2; # "8" com dois alertas
print $str1 eq $str2; # "" (string vazia, i.e. falso)
print $str1 == $str2; # "1" com dois alertas

# O erro clássico
print "sim" == "não"; # "1" com dois alertas; ambos valores são avaliados como sendo 0 quando usados como números
</pre>

<p>A lição é sempre usar o operador correto na situação correta. Existem
operadores distintos para comparar escalares enquanto números e comparar
escalares enquanto strings:</p>

<pre class="perl"># Operadores numéricos:  &lt;,  &gt;, &lt;=, &gt;=, ==, !=, &lt;=&gt;, +, *
# Operadores de strings: <a href="http://perldoc.perl.org/perlop.html#Equality-Operators">lt, gt, le, ge, eq, ne, cmp</a>, <a href="http://perldoc.perl.org/perlop.html#Additive-Operators">.</a>, <a href="http://perldoc.perl.org/perlop.html#Multiplicative-Operators">x</a>
</pre>

<h3>Variáveis do tipo Array</h3>

<p>Uma variável do tipo array é uma lista de escalares indexados por inteiros,
iniciada por 0. Em Python é conhecida como <i>lista</i>, e em PHP é conhecida
como <i>array</i>. Um array é declarado usando uma lista de escalares entre
parêntesis:</p>

<pre class="perl">my @array = (
	"imprima",
	"estas",
	"strings",
	"para ",
	"mim", # não há problema em ter uma vírgula aqui no final
);
</pre>

<p>Você deve usar um cifrão para acessar um valor de um array, pois o valor
que está sendo <em>buscado</em> não é um array, e sim um escalar:</p>

<pre class="perl">print $array[0]; # "imprima"
print $array[1]; # "estas"
print $array[2]; # "strings"
print $array[3]; # "para"
print $array[4]; # "mim"
print $array[5]; # retorna undef, imprime "" e dispara um alerta
</pre>

<p>Você pode usar índices negativos para acessar entradas a partir do final do
array e trabalhar de forma invertida:</p>

<pre class="perl">print $array[-1]; # "mim"
print $array[-2]; # "para"
print $array[-3]; # "strings"
print $array[-4]; # "estas"
print $array[-5]; # "imprima"
print $array[-6]; # retorna undef, imprime "" e dispara um alerta
</pre>

<p>Não ocorre colisão entre um escalar <code>$var</code> e um array
<code>@var</code> contendo uma entrada escalar <code>$var[0]</code>. Mas pode
ocorrer, contudo, confusão por parte do leitor, então evite isso.</p>

<p>Para pegar o tamanho de um array:</p>
<pre class="perl">print "Este array tem ".(scalar @array)."elementos"; # "Este array tem 6 elementos"
print "O último indice ocupado é ".$#array;       # "O último índice ocupado é 5"
</pre>

<p>Os argumentos com os quais o script Perl original foi invocado ficam
armazenados na <a href="http://perldoc.perl.org/perlvar.html">variável
padrão</a> <code>@ARGV</code>.</p>

<p>Variáveis podem ser interpoladas em strings:</p>
<pre class="perl">print "Hello $string"; # "Hello world"
print "@array";        # "imprima estas strings para mim"
</pre>

<p><strong>Cuidado.</strong> Um dia você vai colocar o email de alguém dentro
de uma string, <code>"jeff@gmail.com"</code>. Isso fará o Perl buscar um array
chamado <code>@gmail</code> para interpolar dentro da string, e se ele não
encontrar, um erro em tempo de execução será disparado. A interpolação pode
ser prevenida de duas maneiras: escapando o símbolo, ou usando aspas simples
ao invés de aspas duplas.>/p>

<pre class="perl">print "Hello \$string"; # "Hello $string"
print 'Hello $string';  # "Hello $string"
print "\@array";        # "@array"
print '@array';         # "@array"
</pre>

<h3>Variáveis do tipo Hash</h3>

<p>Uma variável do tipo hash é uma lista de escalares indexadas por strings.
Em Python elas são conhecidas como <i>dicionários</i>, e em PHP são conhecidas
como <i>array</i>.</p>

<pre class="perl">my %cientistas = (
	"Newton"   =&gt; "Isaac",
	"Einstein" =&gt; "Albert",
	"Darwin"   =&gt; "Charles",
);
</pre>

<p>Note o quanto esta declaração é parecida com a declaração de um array. De
fato, a flecha dupla <code>=&gt;</code> é chamada "vírgula gorda", por ser
apenas um sinônimo para o separador vírgula. Uma has é declarada usando uma
lista com um número par de elementos, onde os elementos pares (0,2, ...) são
utilizados como as strings.</p>

<p>De novo, você deve usar um cifrão para acessar um valor de uma hash, pois o
valor sendo <em>acessado</em> não é uma hash, mas um escalar:</p>

<pre class="perl">print $cientistas{"Newton"};   # "Isaac"
print $cientistas{"Einstein"}; # "Albert"
print $cientistas{"Darwin"};   # "Charles"
print $cientistas{"Dyson"};    # retorna undef, imprime "" e dispara um alerta
</pre>

<p>Note as chaves usadas aqui. Novamente, não há colisão entre um escalar
<code>$var</code> e uma hash <code>%var</code> contendo uma entrada escalar
<code>$var{"foo"}</code>.</p>

<p>Você pode converter uma hash diretamente em um array com o dobro de
entradas, alternando entre chaves e valores (e o inverso é igualmente
fácil):</p>
<pre class="perl">my @cientistas = %cientistas;
</pre>

<p>Contudo, diferente de um array, as chaves de uma hash <em>não possuem uma
ordem subjacente</em>. Elas serão retornadas em uma ordem qualquer que seja
mais eficiente. Então, perceba que a <em>ordem</em> foi rearranjada mas os
<em>pares</em> foram mantidos, resultando no seguinte array:</p>

<pre class="perl">print "@cientistas"; # algo como "Einstein Albert Darwin Charles Newton Isaac"
</pre>

<p>Recaptulando, você deve usar <strong>colchetes</strong> para acessar um
valor de um array, mas você deve usar <strong>chaves</strong> para acessar um
valor de uma hash. Os colchetes são efetivamente operadores numéricos e as
chaves são efetivamente operadores de string. O fato de um <em>índice</em>
provido ser um número ou uma string não tem absolutamente nenhuma
significância:</p>

<pre class="perl">my $data = "laranja";
my @data = ("violeta");
my %data = ( "0" =&gt; "azul");

print $data;      # "laranja"
print $data[0];   # "violeta"
print $data["0"]; # "violeta"
print $data{0};   # "azul"
print $data{"0"}; # "azul"
</pre>

<h3>Listas</h3>

<p>Uma <i>lista</i> em Perl é algo diferente de um array ou uma hash. Você acabou de ver uma série de listas:</p>

<pre class="perl">(
	"imprima",
	"estas",
	"strings",
	"para",
	"mim",
)

(
	"Newton"   =&gt; "Isaac",
	"Einstein" =&gt; "Albert",
	"Darwin"   =&gt; "Charles",
)
</pre>

<p><strong>Uma lista não é uma variável.</strong> Uma lista é um
<em>valor</em> efêmero que pode ser <em>atribuído</em> a um array ou uma hash.
É por isso que a sintaxe para declarar variáveis do tipo array e hash é a
mesma. Existem diversas situações onde os termos "lista" e "array" podem ser
usados intercambiavelmente, mas existem igualmente muitas situações onde eles
podem exibir comportamentos sutilmente diferentes e extremamente confusos.</p>

<p>Ok. Lembre-se que <code>=&gt;</code> é somente uma <code>,</code> disfarçada e então olhe para este exemplo:</p>

<pre class="perl">("one", 1, "three", 3, "five", 5)
("one" =&gt; 1, "three" =&gt; 3, "five" =&gt; 5)
</pre>

<p>O uso de <code>=&gt;</code> sugere que uma destas listas é uma declaração
de um array e a outra uma declaração de uma hash. Mas em si mesmas, nenhuma
delas é declaração de nada em particular. São apenas listas. Listas
<em>idênticas</em>. Da mesma forma:</p>

<pre class="perl">()
</pre>

<p>Não existem nem sugestões aqui. Esta lista poderia ser usada para declarar
um array vazio ou uma hash vazia e o interpretador <code>perl</code>
claramente não poderia dizer outra coisa. Uma vez que você entenda este
aspecto singular do Perl, você também vai entender porquê o seguinte fato deve
ser verdadeiro: <strong>Não é possível encadear valores em uma lista.</strong>
Tente:

<pre class="perl">my @array = (
	"maçãs",
	"bananas",
	(
		"lista",
		"interna",
		"diversas",
		"entradas",
	),
	"cerejas",
);
</pre>

<p>O Perl não tem como saber quando <code>("lista", "interna", "diversas",
"entradas")</code> deveria ser um array interno ou uma hash interna. Portanto,
o Perl assume que não é nenhum e <strong>achata a lista toda como uma única
lista longa</strong>:</p>

<pre>print $array[0]; # "maçãs"
print $array[1]; # "bananas"
print $array[2]; # "lista"
print $array[3]; # "interna"
print $array[4]; # "diversas"
print $array[5]; # "entradas"
print $array[6]; # "cerejas"
</pre>

<p>O mesmo é verdade quando a flecha gorda é usada ou não:</p>

<pre class="perl">my %hash = (
	"cerveja" =&gt; "boa",
	"bananas" =&gt; (
		"verde"  =&gt; "aguarde",
		"amarela" =&gt; "coma",
	),
);

# O código acima dispara um alerta porque a hash foi declara usando uma lista
com 7 elementos

print $hash{"cerveja"}; # "boa"
print $hash{"bananas"}; # "verde"
print $hash{"aguarde"}; # "amarela";
print $hash{"coma"};    # undef, imprime "" e dispara um alerta
</pre>

<p>É claro, isso facilita a concatenação de múltiplos arrays:</p>

<pre class="perl">my @ossos   = ("úmero", ("mandíbula", "crânio"), "tíbia");
my @dedos = ("polegar", "indicador", "médio", "anular", "mindinho");
my @partes   = (@ossos, @dedos, ("pé", "dedos do pé"), "globo ocular", "articulação");
print @partes;
</pre>

<p>Mais sobre o isso em breve.</p>

<h2>Contexto</h2>

<p>A característica mais distinta do Perl é que seu código é <i>sensível a
  contexto</i>. <strong>Toda expressão em Perl é avaliada ou num contexto
escalar, ou num contexto de lista</strong>, conforme o que é esperado que a
expressão produza. Sem saber o contexto onde uma expressão é avaliada, é
impossível determinar o valor final de tal avaliação.</p>

<p>Uma atribuição escalar tal como <code>my $scalar =</code> tem sua expressão
avaliada em contexto escalar. Aqui, a expressão é <code>"Mendeleev"</code>:</p>
<pre class="perl">my $scalar = "Mendeleev";</pre>

<p>Uma atribuição de array ou hash tal como <code>my @array =</code> or <code>my
%hash =</code> tem sua expressão avaliada em contexto de lista. Aqui, a
expressão é <code>("Alpha", "Beta", "Gamma", "Pie")</code> (ou <code>("Alpha"
=&gt; "Beta", "Gamma" =&gt; "Pie")</code>, ambas são equivalentes):</p>
<pre class="perl">my @array = ("Alpha", "Beta", "Gamma", "Pie");
my %hash = ("Alpha" =&gt; "Beta", "Gamma" =&gt; "Pie");</pre>

<p>Uma expressão escalar avaliada em contexto de lista é silenciosamente
convertida em uma lista de um único elemento:i</p>
<pre class="perl">my @array = "Mendeleev"; # o mesmo que 'my @array = ("Mendeleev");'</pre>

<p>Uma expressão de array avaliada em contexto escalar retorna o tamanho do
array:</p>

<pre class="perl">my @array = ("Alpha", "Beta", "Gamma", "Pie");
my $scalar = @array;
print $scalar; # "4"
</pre>

<p>Uma expressão do tipo lista (uma lista é diferente de um array, lembra?)
avaliada em um contexto escalar não retorna o tamanho da lista, mas <em>o último
elemento escalar da lista</em>:</p>
<pre class="perl">my $scalar = ("Alpha", "Beta", "Gamma", "Pie");
print $scalar; # "Pie"
</pre>

<p>A função <code><a
href="http://perldoc.perl.org/functions/print.html">print</a></code> avalia
todos os seus argumentos em um contexto de lista. De fato, <code>print</code>
aceita um número ilimitado de argumentos e imprime um após o outro, o que
significa que pode ser usado para imprimir arrays diretamente:</p>

<pre class="perl">my @array = ("Alpha", "Beta", "Goo");
my $scalar = "-X-";
print @array;              # "AlphaBetaGoo";
print $scalar, @array, 98; # "-X-AlphaBetaGoo98";
</pre>

<p><strong>Cuidado.</strong> Muitas expressões e <a
href="http://perldoc.perl.org/perlfunc.html">funções</a> em Perl demonstram um
comportamento radicalmente diferente conforme o contexto onde são avaliadas. O
exemplo mais proeminente é a função <code><a
href="http://perldoc.perl.org/functions/reverse.html">reverse</a></code>. Em
contexto de lista, <code>reverse</code> trata seus argumentos como uma lista, e
a inverte. Em contexto escalar, <code>reverse</code> concatena toda lista e
depois reverte-a como uma única palavra.</p>

<pre class="perl">print reverse "hello world"; # "hello world"
my $string = reverse "hello world";
print $string; # "dlrow olleh"
</pre>

<p>Você pode forçar qualquer expressão a ser avaliada em contexto escalar usando
a função <code><a
href="http://perldoc.perl.org/functions/scalar.html">scalar</a></code>:</p>

<pre class="perl">print scalar reverse "hello world"; # "dlrow olleh"</pre>

<p>Lembra-se como usamos <code>scalar</code> antes, para obter o tamanho do
array?</p>

<h2>Referências e estruturas de dados aninhadas</h2>

<p>Da mesma forma que listas não podem conter listas como elementos, <strong>
arrays e hashes não podem conter arrays e hashes como elementos.</strong>
Eles só podem conter escalares. Veja o que acontece quando tentamos:</p>

<pre class="perl">my @outer = ("Sun", "Mercury", "Venus", undef, "Mars");
my @inner = ("Earth", "Moon");

$outer[3] = @inner;

print $outer[3]; # "2"
</pre>

<p><code>$outer[3]</code> é um escalar, então ele demanda um valor escalar.
Quando você tenta atribuir a ele um valor de array como <code>@inner</code>,
<code>@inner</code> é considerado num contexto escalar. Isso é o mesmo que
assinalar <code>scalart @inner</code>, que é o tamanho do array <code>@inner
</code>, que é 2.</p>

<p>Contudo, uma variável escalar pode conter uma <i>referência</i> para
qualquer variável, incluindo uma variável do tipo array ou do tipo hash.
Assim é como estruturas de dados mais complicadas são criadas em Perl.</p>

<p>Uma referência é criada usando uma contrabarra.</p>

<pre class="perl">my $colour    = "Indigo";
my $scalarRef = \$colour;
</pre>

<p>Em qualquer lugar que você normalmente usaria o nome de uma variável,
você pode simplesmente colocar chaves no lugar, e, dentro delas, colocar uma
<em>referência</em> para uma variável.</p>

<pre class="perl">print $colour;         # "Indigo"
print $scalarRef;      # e.g. "SCALAR(0x182c180)"
print ${ $scalarRef }; # "Indigo"
</pre>

<p>Contanto que o resultado não seja ambíguo, você também pode omitir as
chaves:</p>

<pre class="perl">print $$scalarRef; # "Indigo"</pre>

<p>Se sua referência é uma referência para uma variável do tipo array ou
hash, você pode extrair dados dela usando chaves ou usando o operador mais
popular, a flecha: <code>-&gt;</code>:</p>

<pre class="perl">my @colours = ("Red", "Orange", "Yellow", "Green", "Blue");
my $arrayRef = \@colours;

print $colours[0];       # acesso direto ao array
print ${ $arrayRef }[0]; # use a referência para chegar ao array
print $arrayRef-&gt;[0];    # exatamente a mesma coisa

my %atomicWeights = ("Hydrogen" =&gt; 1.008, "Helium" =&gt; 4.003, "Manganese" =&gt; 54.94);
my $hashRef = \%atomicWeights;

print $atomicWeights{"Helium"}; # acesso direto à hash
print ${ $hashRef }{"Helium"};  # use uma referência para chegar à hash
print $hashRef-&gt;{"Helium"};     # exatamente a mesma coisa - isso é muito comum
</pre>

<h3>Declarando uma estrutura de dados</h3>

<p>Aqui estão quatro exemplos, mas na prática o último é o mais útil.</p>

<pre class="perl">my %owner1 = (
  "name" =&gt; "Santa Claus",
  "DOB"  =&gt; "1882-12-25",
);

my $owner1Ref = \%owner1;

my %owner2 = (
  "name" =&gt; "Mickey Mouse",
  "DOB"  =&gt; "1928-11-18",
);

my $owner2Ref = \%owner2;

my @owners = ( $owner1Ref, $owner2Ref );

my $ownersRef = \@owners;

my %account = (
  "number" =&gt; "12345678",
  "opened" =&gt; "2000-01-01",
  "owners" =&gt; $ownersRef,
);
</pre>

<p>Obviamente isto é desnecessariamente trabalhoso, pois você pode reduzir
tal exemplo a:</p>

<pre class="perl">my %owner1 = (
  "name" =&gt; "Santa Claus",
  "DOB"  =&gt; "1882-12-25",
);

my %owner2 = (
  "name" =&gt; "Mickey Mouse",
  "DOB"  =&gt; "1928-11-18",
);

my @owners = ( \%owner1, \%owner2 );

my %account = (
  "number" =&gt; "12345678",
  "opened" =&gt; "2000-01-01",
  "owners" =&gt; \@owners,
);
</pre>

<p>Também é possível declarar arrays e hashes <i>anônimos</i> usando
símbolos diferentes. Usamos colchetes para um array anônimo e chaves para
uma hash anônima. O valor retornado em cada caso é uma <em>referência</em>
para a estrutura de dados anônima em questão. Preste atenção, o exemplo a
seguir resulta exatamente na mesma <code>%account</code> acima:</p>

<pre class="perl"># Chaves definem uma hash anônima
my $owner1Ref = {
  "name" =&gt; "Santa Claus",
  "DOB"  =&gt; "1882-12-25",
};

my $owner2Ref = {
  "name" =&gt; "Mickey Mouse",
  "DOB"  =&gt; "1928-11-18",
};

# Colchetes definem um array anônimo
my $ownersRef = [ $owner1Ref, $owner2Ref ];

my %account = (
  "number" =&gt; "12345678",
  "opened" =&gt; "2000-01-01",
  "owners" =&gt; $ownersRef,
);
</pre>

<p>Ou, em resumo (e esta é a forma que <em>realmente</em> deveria usar
quando estiver declarando estruturas de dado complexas em uma só atribuição)
</p>

<pre class="perl">my %account = (
  "number" =&gt; "31415926",
  "opened" =&gt; "3000-01-01",
  "owners" =&gt; [
    {
      "name" =&gt; "Philip Fry",
      "DOB"  =&gt; "1974-08-06",
    },
    {
      "name" =&gt; "Hubert Farnsworth",
      "DOB"  =&gt; "2841-04-09",
    },
  ],
);
</pre>

<h3>Obtendo informação de uma estrutura de dados</h3>

<p>Agora vamos assumir que você ainda tem <code>%account</code> acessível no
seu escopo, mas todo resto (se é que havia algo além disso) saiu do escopo.
Você pode imprimir a informação revertendo o mesmo procedimento em cada caso.
Novamente, aqui estão quatro exemplos, dos quais o último é o mais útil:</p>


<pre class="perl">my $ownersRef = $account{"owners"};
my @owners    = @{ $ownersRef };
my $owner1Ref = $owners[0];
my %owner1    = %{ $owner1Ref };
my $owner2Ref = $owners[1];
my %owner2    = %{ $owner2Ref };
print "Conta #", $account{"number"}, "\n";
print "Aberta em ", $account{"opened"}, "\n";
print "Titulares:\n";
print "\t", $owner1{"name"}, " (born ", $owner1{"DOB"}, ")\n";
print "\t", $owner2{"name"}, " (born ", $owner2{"DOB"}, ")\n";
</pre>

<p>Ou, em suma:</p>

<pre class="perl">my @owners = @{ $account{"owners"} };
my %owner1 = %{ $owners[0] };
my %owner2 = %{ $owners[1] };
print "Conta #", $account{"number"}, "\n";
print "Aberta em ", $account{"opened"}, "\n";
print "Titulares:\n";
print "\t", $owner1{"name"}, " (born ", $owner1{"DOB"}, ")\n";
print "\t", $owner2{"name"}, " (born ", $owner2{"DOB"}, ")\n";
</pre>

<p>Ou usando referências e o operador <code>-&gt;</code>:

<pre class="perl">my $ownersRef = $account{"owners"};
my $owner1Ref = $ownersRef-&gt;[0];
my $owner2Ref = $ownersRef-&gt;[1];
print "Conta #", $account{"number"}, "\n";
print "Aberta em ", $account{"opened"}, "\n";
print "Titulares:\n";
print "\t", $owner1Ref-&gt;{"name"}, " (born ", $owner1Ref-&gt;{"DOB"}, ")\n";
print "\t", $owner2Ref-&gt;{"name"}, " (born ", $owner2Ref-&gt;{"DOB"}, ")\n";
</pre>

<p>E se deixarmos de lado os valores intermediários:</p>

<pre class="perl">print "Conta #", $account{"number"}, "\n";
print "Aberta em ", $account{"opened"}, "\n";
print "Titulares:\n";
print "\t", $account{"owners"}-&gt;[0]-&gt;{"name"}, " (born ", $account{"owners"}-&gt;[0]-&gt;{"DOB"}, ")\n";
print "\t", $account{"owners"}-&gt;[1]-&gt;{"name"}, " (born ", $account{"owners"}-&gt;[1]-&gt;{"DOB"}, ")\n";
</pre>

<h3>Como atirar no próprio pé com referências para arrays</h3>

<p>Este array tem cinco elementos:</p>
<pre class="perl">my @array1 = (1, 2, 3, 4, 5);
print @array1; # "12345"
</pre>

<p>Este array, no entanto, tem UM elemento (que no caso é uma referência
para um array anônimo de cinco elementos):</p>

<pre class="perl">my @array2 = [1, 2, 3, 4, 5];
print @array2; # e.g. "ARRAY(0x182c180)"
</pre>

<p>Este <em>escalar</em> é uma referência para um array anônimo de cinco
elementos:</p>

<pre class="perl">my $array3Ref = [1, 2, 3, 4, 5];
print $array3Ref;      # e.g. "ARRAY(0x22710c0)"
print @{ $array3Ref }; # "12345"
print @$array3Ref;     # "12345"
</pre>
