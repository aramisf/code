--- bgp_dump.c.orig	2011-09-29 09:59:32.000000000 -0300
+++ bgp_dump.c	2012-02-02 16:19:39.907999032 -0200
@@ -18,6 +18,8 @@
 Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 02111-1307, USA.  */
 
+#include <stdio.h>
+#include <errno.h>
 #include <zebra.h>
 
 #include "log.h"
@@ -33,7 +35,7 @@
 #include "bgpd/bgp_route.h"
 #include "bgpd/bgp_attr.h"
 #include "bgpd/bgp_dump.h"
-
+
 enum bgp_dump_type
 {
   BGP_DUMP_ALL,
@@ -60,6 +62,8 @@
 
 static int bgp_dump_interval_func (struct thread *);
 
+char *dump_path(char *, const char []);
+
 struct bgp_dump
 {
   enum bgp_dump_type type;
@@ -89,22 +93,93 @@
 
 /* Dump whole BGP table is very heavy process.  */
 struct thread *t_bgp_dump_routes;
-
+
+char *dump_path(char *pathf, const char arq[10])
+{
+  	typedef struct Hora
+    {
+        int hora;
+        int min;
+        int dia;
+        int mes;
+        int ano;
+    } hr;
+
+    struct Hora dt_hr;
+    struct tm *data;
+    time_t tempo;
+    struct stat st;
+    char diretorio[100], *arquivo;
+
+    tempo = time(NULL);
+    data = localtime(&tempo);
+    arquivo = (char *)malloc(sizeof(char)*100);
+    
+    // Definindo estruturas para armazenar os valores da data e hora atuais:
+    dt_hr.hora = data -> tm_hour;
+    dt_hr.min = data -> tm_min;
+    dt_hr.dia = data -> tm_mday;
+    dt_hr.mes = data -> tm_mon+(1);
+    dt_hr.ano = data -> tm_year+(1900);
+    
+    // Caminho:
+    errno = 0;
+    stat(pathf,&st);
+    
+    umask(NULL);
+    if ((errno == ENOENT || !S_ISDIR(st.st_mode))) {
+        mkdir(pathf,0755);
+    }
+      
+    // Criando diretorios dentro da pasta de log.
+    // Ano:
+    sprintf(diretorio,"%s/%d",pathf,dt_hr.ano);
+    errno = 0;
+    stat(diretorio,&st);
+    
+    if ((errno == ENOENT || !S_ISDIR(st.st_mode)))
+        mkdir(diretorio,0755);
+      
+      
+    // Mes:
+    sprintf(diretorio,"%s/%d/%.2d",pathf,dt_hr.ano,dt_hr.mes);
+    errno = 0;
+    stat(diretorio,&st);
+    
+    if ((errno == ENOENT || !S_ISDIR(st.st_mode)))
+        mkdir(diretorio,0755);
+      
+    
+    // Dia:
+    sprintf(diretorio,"%s/%d/%.2d/%.2d",pathf,dt_hr.ano,dt_hr.mes,dt_hr.dia);
+    errno = 0;
+    stat(diretorio,&st);
+    
+    if ((errno == ENOENT || !S_ISDIR(st.st_mode)))
+        mkdir(diretorio,0755);
+    
+      
+    // E finalmente o arquivo final:
+    sprintf(arquivo,"%s/%s_%d%.2d%.2d%.2d%.2d.dump",diretorio,arq,dt_hr.ano,dt_hr.mes,dt_hr.dia,dt_hr.hora,dt_hr.min);
+    return arquivo;
+}
+
 /* Some define for BGP packet dump. */
 static FILE *
 bgp_dump_open_file (struct bgp_dump *bgp_dump)
 {
-  int ret;
+  int ret=0;
   time_t clock;
   struct tm *tm;
-  char fullpath[MAXPATHLEN];
+//   char fullpath[MAXPATHLEN];
   char realpath[MAXPATHLEN];
   mode_t oldumask;
-
+  char *finalpath;
+  char *tmp;
   time (&clock);
   tm = localtime (&clock);
 
-  if (bgp_dump->filename[0] != DIRECTORY_SEP)
+/*if (bgp_dump->filename[0] != DIRECTORY_SEP)
     {
       sprintf (fullpath, "%s/%s", vty_get_cwd (), bgp_dump->filename);
       ret = strftime (realpath, MAXPATHLEN, fullpath, tm);
@@ -117,12 +192,44 @@
       zlog_warn ("bgp_dump_open_file: strftime error");
       return NULL;
     }
-
+*/
   if (bgp_dump->fp)
     fclose (bgp_dump->fp);
 
 
-  oldumask = umask(0777 & ~LOGFILE_MASK);
+  
+  if (bgp_dump->type ==  BGP_DUMP_ROUTES){
+	finalpath=strdup(bgp_dump->filename);
+	tmp=dump_path(finalpath, "routes_mrt");
+	ret = strftime (realpath, MAXPATHLEN, tmp, tm);
+	free(tmp);
+	free(finalpath);
+  }
+    
+  if (bgp_dump->type == BGP_DUMP_ALL ){
+	finalpath=strdup(bgp_dump->filename);
+	tmp=dump_path(finalpath, "dumpall");
+	ret = strftime (realpath, MAXPATHLEN, tmp, tm);
+	free(tmp);
+	free(finalpath);
+  }
+  
+  if (bgp_dump->type == BGP_DUMP_UPDATES ){
+        finalpath=strdup(bgp_dump->filename);
+  	tmp=dump_path(finalpath,"updates");
+	ret = strftime (realpath, MAXPATHLEN, tmp, tm);
+        free(tmp);
+        free(finalpath);
+  } 
+
+  if (ret == 0)
+    {
+      zlog_warn ("bgp_dump_open_file: strftime error");
+      return NULL;
+    }
+
+  //oldumask = umask(0777 & ~LOGFILE_MASK);
+  oldumask = umask(0022);
   bgp_dump->fp = fopen (realpath, "w");
 
   if (bgp_dump->fp == NULL)
@@ -535,7 +642,7 @@
   if (type == BGP_MSG_UPDATE)
     bgp_dump_packet_func (&bgp_dump_updates, peer, packet);
 }
-
+
 static unsigned int
 bgp_dump_parse_time (const char *str)
 {
@@ -845,7 +952,7 @@
     }
   return 0;
 }
-
+
 /* Initialize BGP packet dump functionality. */
 void
 bgp_dump_init (void)
